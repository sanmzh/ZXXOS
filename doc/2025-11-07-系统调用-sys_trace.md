创建一个新的trace系统调用来控制跟踪。它应该有一个参数，这个参数是一个整数“掩码”（mask），它的比特位指定要跟踪的系统调用。例如，要跟踪fork系统调用，程序调用trace(1 << SYS_fork)，其中SYS_fork是*kernel/syscall.h*中的系统调用编号。

如果在掩码中设置了系统调用的编号，则必须修改xv6内核，以便在每个系统调用即将返回时打印出一行。该行应该包含进程id、系统调用的名称和返回值；您不需要打印系统调用参数。trace系统调用应启用对调用它的进程及其随后派生的任何子进程的跟踪，但不应影响其他进程。

# sys_trace 系统调用实现总结
1. 系统调用定义：

	- 在 kernel/syscall.h 中定义了系统调用编号 SYS_trace 为 22
	- 在 user/user.h 中声明了用户空间的 trace 函数
	- 在 user/usys.pl 中添加了 trace 系统调用的用户空间入口
2. 内核实现：

	- 在 kernel/sysproc.c 中实现了 sys_trace 函数，它接收一个掩码参数并保存到当前进程的 trace_mask 字段
	- 在 kernel/syscall.c 中实现了系统调用处理逻辑，当进程设置了相应系统调用的跟踪掩码时，会在系统调用返回前打印进程ID、系统调用名称和返回值
	- 在 kernel/proc.h 中的进程结构体中添加了 trace_mask 字段，用于存储进程的系统调用跟踪掩码
	- 在 kernel/proc.c 中的 fork 函数中实现了子进程继承父进程的 trace_mask


系统调用的全流程：
```bash
user/user.h:		用户态程序调用跳板函数 trace()
user/usys.S:		跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态
kernel/syscall.c	到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。
kernel/syscall.c	syscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。
kernel/sysproc.c	到达 sys_trace() 函数，执行具体内核操作
```
这么繁琐的调用流程的主要目的是实现用户态和内核态的良好隔离。

并且由于内核与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过 C 语言参数的形式传过来，而是需要使用 argaddr、argint、argstr 等系列函数，从进程的 trapframe 中读取用户进程寄存器中的参数。

同时由于页表不同，指针也不能直接互通访问（也就是内核不能直接对用户态传进来的指针进行解引用），而是需要使用 copyin、copyout 方法结合进程的页表，才能顺利找到用户态指针（逻辑地址）对应的物理内存地址。

# 使用

参考 user/trace_test.c

```bash
3: syscall getpid -> 3
```
打印：
进程ID: 系统调用名称 -> 系统调用返回值


# 参考

[实现参考](https://www.cnblogs.com/Amroning/p/18503148)

[系统调用流程分析](https://zhuanlan.zhihu.com/p/693173080)