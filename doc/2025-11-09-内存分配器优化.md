https://pdos.csail.mit.edu/6.828/2025/labs/lock.html

# 内存分配器优化

kalloctest 中锁竞争的根本原因是 kalloc() 有一个单一的空闲列表，由一个单一的锁保护。为了消除锁竞争，你必须重新设计内存分配器以避免单一的锁和列表。基本思想是维护每个 CPU 一个空闲列表，每个列表有自己的锁。在不同的 CPU 上的分配和释放可以并行运行，因为每个 CPU 将操作不同的列表。主要挑战将是处理一个 CPU 的空闲列表为空，但另一个 CPU 的列表有可用内存的情况；在这种情况下，一个 CPU 必须“窃取”另一个 CPU 的部分空闲列表。

实现每个 CPU 的空闲列表，并在 CPU 的空闲列表为空时进行窃取。你必须给你的所有锁命名，且名称必须以"kmem"开头。也就是说，你应该为每个锁调用 initlock ，并传递一个以"kmem"开头的名称。


# 实现每个CPU的空闲列表以减少内存分配器锁竞争

## 实现概述

本实现针对xv6操作系统的内存分配器进行了优化，将单一的空闲列表和锁结构替换为每个CPU一个的空闲列表和锁，从而减少了多核环境下的锁竞争问题。

## 实现细节

### 1. 数据结构修改

原始实现使用单一的空闲列表和锁：

```c
struct {
  struct spinlock lock;
  struct run *freelist;
} kmem;
```

修改后，使用数组为每个CPU维护独立的空闲列表和锁：

```c
struct {
  struct spinlock lock;
  struct run *freelist;
} kmem[NCPU];
```

### 2. 初始化函数修改

修改了`kinit()`函数，为每个CPU的锁进行初始化：

```c
void
kinit()
{
  char lock_name[16];
  for (int i = 0; i < NCPU; i++) {
    snprintf(lock_name, sizeof(lock_name), "kmem_%d", i);
    initlock(&kmem[i].lock, lock_name);
  }
  freerange(end, (void*)PHYSTOP);
}
```

每个锁以"kmem"开头命名，满足实验要求。

### 3. 内存释放函数修改

修改了`kfree()`函数，使释放的内存添加到当前CPU的空闲列表：

```c
void
kfree(void *pa)
{
  struct run *r;

  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("kfree");

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  r = (struct run*)pa;

  push_off();
  int cpu_id = cpuid();
  acquire(&kmem[cpu_id].lock);
  r->next = kmem[cpu_id].freelist;
  kmem[cpu_id].freelist = r;
  release(&kmem[cpu_id].lock);
  pop_off();
}
```

使用`push_off()`和`pop_off()`确保安全地获取CPU ID。

### 4. 内存分配函数修改

重写了`kalloc()`函数，实现以下逻辑：
1. 首先尝试从当前CPU的空闲列表分配
2. 如果当前CPU的空闲列表为空，从其他CPU窃取一半的内存块

```c
void *
kalloc(void)
{
  struct run *r;

  push_off();
  int cpu_id = cpuid();
  
  acquire(&kmem[cpu_id].lock);
  r = kmem[cpu_id].freelist;
  if(r) {
    kmem[cpu_id].freelist = r->next;
    release(&kmem[cpu_id].lock);
    pop_off();
  } else {
    // 当前CPU的空闲列表为空，尝试从其他CPU窃取
    release(&kmem[cpu_id].lock);
    
    // 尝试从其他CPU获取内存
    for(int i = 0; i < NCPU; i++) {
      if(i == cpu_id) continue;
      
      acquire(&kmem[i].lock);
      r = kmem[i].freelist;
      if(r) {
        // 从其他CPU的列表中取走一半的内存块
        int count = 0;
        struct run *p = r;
        while(p) {
          count++;
          p = p->next;
        }
        
        // 取走一半
        int steal = count / 2;
        if(steal == 0) steal = 1; // 至少取走一个
        
        p = r;
        for(int j = 0; j < steal - 1; j++) {
          p = p->next;
        }
        
        kmem[i].freelist = p->next;
        p->next = 0;
        
        // 将窃取的内存放入当前CPU的列表
        acquire(&kmem[cpu_id].lock);
        kmem[cpu_id].freelist = r;
        r = kmem[cpu_id].freelist;
        kmem[cpu_id].freelist = r->next;
        release(&kmem[cpu_id].lock);
        
        release(&kmem[i].lock);
        break;
      }
      release(&kmem[i].lock);
    }
    pop_off();
  }

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}
```

### 5. 初始内存分配函数修改

修改了`freerange()`函数，使所有初始内存分配给运行它的CPU：

```c
void
freerange(void *pa_start, void *pa_end)
{
  char *p;
  p = (char*)PGROUNDUP((uint64)pa_start);
  
  push_off();
  int cpu_id = cpuid();
  
  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE) {
    struct run *r;
    
    // Fill with junk to catch dangling refs.
    memset(p, 1, PGSIZE);
    
    r = (struct run*)p;
    
    acquire(&kmem[cpu_id].lock);
    r->next = kmem[cpu_id].freelist;
    kmem[cpu_id].freelist = r;
    release(&kmem[cpu_id].lock);
  }
  
  pop_off();
}
```


## 1. kalloctest 测试原理

`kalloctest` 是专门设计用来测试内存分配器锁竞争的程序。它的工作原理如下：

### 测试流程
1. **创建多个进程**：kalloctest 创建多个进程，每个进程在不同的 CPU 核心上运行
2. **内存分配与释放**：每个进程反复执行以下操作：
   - 通过 `sbrk()` 系统调用扩展其地址空间（触发 `kalloc()` 调用）
   - 通过 `sbrk()` 负值缩小其地址空间（触发 `kfree()` 调用）
3. **统计锁竞争**：xv6 内核中的 `acquire()` 函数维护了每个锁的统计信息：
   - `acquire` 调用计数
   - `acquire` 中循环尝试但未能设置锁的次数（锁竞争指标）

### 输出解读
kalloctest 的输出包含以下信息：
- 每个锁的名称（我们实现中是 kmem_0, kmem_1 等）
- 每个锁的 `#test-and-set` 值（表示获取锁时需要循环等待的次数）
- 总体的 kmem 锁竞争次数

### 为什么这个测试有效
- 多进程同时分配和释放内存会导致频繁的 `kalloc()` 和 `kfree()` 调用
- 在原始实现中，所有这些调用都需要获取同一个锁，导致严重的锁竞争
- 在我们的实现中，每个 CPU 有自己的锁，大大减少了竞争


## 测试结果解读

### 成功的指标
1. **kalloctest**：
   - 每个 kmem 锁的 `#test-and-set` 值应该很低（接近0）
   - 总体的 kmem 锁竞争次数应该显著减少


## 性能分析

这个实现通过以下方式减少了锁竞争：
1. 每个CPU操作自己的空闲列表，无需等待其他CPU释放锁
2. 只有在当前CPU的空闲列表为空时才会发生锁竞争（窃取操作）
3. 窃取操作会取走一半的内存块，减少频繁窃取的需要

这种设计大大减少了kalloctest中报告的锁竞争次数，同时保持了内存分配的正确性和效率。

---

# bug

# 2025-11-09			--  fixed - 2025-11-09

优化的 内存分配器 测试有bug

```bash
$ kalloctest
start test1
test1 results:
--- lock kmem stats
--- top 5 contended locks:
lock: uart: #test-and-set 159853 #acquire() 1698
lock: virtio_disk: #test-and-set 138950 #acquire() 183
lock: proc: #test-and-set 72396 #acquire() 233832
lock: proc: #test-and-set 58193 #acquire() 633815
lock: refcnt: #test-and-set 47537 #acquire() 400572
tot= 0
test1 OK
start test2
total free number of pages: 32285 (out of 32768)
..........
test2 OK
start test3
..........child done 10000
test3 FAIL: losing pages 32285 31995
```


```bash
hart 1 starting
hart 3 starting
hart 2 starting
init: starting sh
$ kalloctest
start test1
test1 results:
--- lock kmem stats
--- top 5 contended locks:
lock: virtio_disk: #test-and-set 74460 #acquire() 168
lock: proc: #test-and-set 48576 #acquire() 623252
lock: uart: #test-and-set 43492 #acquire() 122
lock: proc: #test-and-set 37326 #acquire() 623249
lock: refcnt: #test-and-set 30752 #acquire() 400490
tot= 0
test1 OK
start test2
total free number of pages: 32285 (out of 32768)
..........
test2 OK
start test3
.........panic: cow_handler: out of memory, killing process
backtrace:
0x0000000080000898
0x0000000080002582
0x0000000080003782
```

```bash
$ kalloctest
start test1
test1 results:
--- lock kmem stats
--- top 5 contended locks:
lock: virtio_disk: #test-and-set 108367 #acquire() 168
lock: proc: #test-and-set 54092 #acquire() 627580
lock: refcnt: #test-and-set 43997 #acquire() 400490
lock: proc: #test-and-set 33678 #acquire() 627581
lock: proc: #test-and-set 28394 #acquire() 227420
tot= 0
test1 OK
start test2
total free number of pages: 32285 (out of 32768)
..........
test2 OK
start test3
..........child done 10000

test3 OK
start test4
............................child done 100000
.child done 100000
.child done 100000
--- lock kmem stats
--- top 5 contended locks:
lock: wait_lock: #test-and-set 52400605 #acquire() 40032
lock: proc: #test-and-set 33066829 #acquire() 1383146
lock: : #test-and-set 791403 #acquire() 610751
lock: : #test-and-set 707821 #acquire() 603219
lock: refcnt: #test-and-set 360700 #acquire() 2969579
tot= 0

test4 OK
$ kalloctest
start test1
test1 results:
--- lock kmem stats
--- top 5 contended locks:
lock: wait_lock: #test-and-set 52416159 #acquire() 40044
lock: proc: #test-and-set 33079974 #acquire() 1614700
lock: : #test-and-set 791403 #acquire() 727045
lock: : #test-and-set 707821 #acquire() 739849
lock: refcnt: #test-and-set 442297 #acquire() 3369784
tot= 0
test1 OK
start test2
total free number of pages: 32285 (out of 32768)
..........
test2 OK
start test3
.........panic: panic: cowcow_handler: out of memory, killing process
backtrace:
0x00000000800_handler: out of memory, killing process
backtrace:
0x0000000080000898
0x0000000080002548
0x0000000080003748
00898
0x0000000080002548
0x0000000080003748
```


## Bug 解决报告：COW 内存管理中的内存泄漏与系统崩溃问题

## 问题分析

在 kalloctest 的测试中，特别是在 test3 和 test4 中，系统进行了大量的 fork 操作，创建了多个进程，这些进程共享内存页面，使用 COW (Copy-On-Write) 机制。测试失败的主要原因是：

1. **内存泄漏**：引用计数管理不当，导致页面没有被正确释放
2. **系统崩溃**：在内存不足时，cow_handler 函数调用 panic 导致整个系统崩溃
3. **内存分配策略不够健壮**：在内存严重不足时，系统无法有效地回收和重新分配内存

## 问题解决过程

### 1. 初始问题：内存泄漏

**问题**：在 dec_refcnt 函数中，只是简单地减少引用计数，但没有在引用计数为 0 时释放页面，导致内存泄漏。

**解决方案**：修改 dec_refcnt 函数，当引用计数为 0 时，直接将页面释放到空闲列表，避免递归调用 kfree。

```c
// 减少引用计数
void
dec_refcnt(void *pa)
{
  int idx = ((uint64)pa - KERNBASE) / PGSIZE;
  acquire(&refcnt.lock);
  refcnt.ref_count[idx]--;
  if(refcnt.ref_count[idx] == 0) {
    release(&refcnt.lock);
    // 引用计数为0，直接释放页面到空闲列表
    // 不调用kfree，避免递归
    struct run *r = (struct run*)pa;
    
    // Fill with junk to catch dangling refs.
    memset(pa, 1, PGSIZE);
    
    push_off();
    int cpu_id = cpuid();
    acquire(&kmem[cpu_id].lock);
    r->next = kmem[cpu_id].freelist;
    kmem[cpu_id].freelist = r;
    release(&kmem[cpu_id].lock);
    pop_off();
    return;
  }
  release(&refcnt.lock);
}
```

### 2. 第二个问题：系统崩溃

**问题**：在 cow_handler 函数中，当内存不足时调用 panic 导致整个系统崩溃，而不是只杀死当前进程。

**解决方案**：移除 panic 调用，改为打印错误信息并返回 -1，只杀死当前进程。

```c
// 如果仍然无法分配内存，杀死进程
if(new_pa == 0) {
  struct proc *p = myproc();
  if(p) {
    printf("cow_handler: out of memory, killing process %d\n", p->pid);
    setkilled(p);
    return -1;
  }
  return -1;
}
```

### 3. 第三个问题：内存分配策略不够健壮

**问题**：在内存严重不足时，系统无法有效地回收和重新分配内存，导致进程被杀死。

**解决方案**：增加更健壮的内存分配策略，在从其他 CPU 窃取内存失败后，尝试等待一段时间并重新分配内存。

```c
// 如果仍然无法分配内存，尝试等待一段时间
if(new_pa == 0) {
  // 短暂等待，希望其他进程释放内存
  for(int i = 0; i < 100 && new_pa == 0; i++) {
    yield();
    new_pa = (uint64)kalloc();
  }
}
```

### 4. 第四个问题：kalloc 函数的内存回收机制

**问题**：在所有 CPU 的空闲列表都为空时，kalloc 函数无法分配内存。

**解决方案**：修改 kalloc 函数，当所有 CPU 的空闲列表都为空时，尝试从其他 CPU 的空闲列表中取走一个页面。

```c
} else {
  // 如果所有CPU的空闲列表都为空，尝试从其他进程回收内存
  // 这是一个极端情况，只在内存严重不足时使用
  push_off();
  int cpu_id = cpuid();
  
  // 尝试从每个CPU的空闲列表中取走一个页面
  for(int i = 0; i < NCPU; i++) {
    if(i == cpu_id) continue;
    
    acquire(&kmem[i].lock);
    if(kmem[i].freelist) {
      struct run *p = kmem[i].freelist;
      kmem[i].freelist = p->next;
      release(&kmem[i].lock);
      
      // 初始化引用计数为1
      acquire(&refcnt.lock);
      int idx = ((uint64)p - KERNBASE) / PGSIZE;
      refcnt.ref_count[idx] = 1;
      release(&refcnt.lock);
      
      r = p;
      break;
    }
    release(&kmem[i].lock);
  }
  
  pop_off();
  
  if(r) {
    memset((char*)r, 5, PGSIZE); // fill with junk
  }
}
```

## 测试结果

经过上述修改，kalloctest 的所有测试都能稳定通过，包括多次运行：
- test1 OK
- test2 OK
- test3 OK
- test4 OK

## 结论

这个 bug 的根本原因在于 COW 实现中的引用计数管理不完整和内存分配策略不够健壮。通过修改 dec_refcnt 函数、cow_handler 函数和 kalloc 函数，我们解决了内存泄漏和系统崩溃问题，使系统在处理大量 fork 操作和 COW 页面时更加健壮。

这个修复不仅解决了 kalloctest 的问题，还提高了整个系统的内存管理效率，特别是在处理大量 fork 操作和 COW 页面时。

---


# 内存分配器与 COW 实现优化报告

## 1. 内存分配器优化的原因

在 kalloctest 测试中，特别是在 test3 和 test4 中，系统进行了大量的 fork 操作，创建了多个进程，这些进程共享内存页面，使用 COW (Copy-On-Write) 机制。测试失败的主要原因包括：

1. **内存分配器效率低下**：原始的内存分配器在多核环境下效率不高，每个 CPU 维护自己的空闲列表，但缺乏有效的负载均衡机制。

2. **内存泄漏**：引用计数管理不当，导致页面没有被正确释放，造成内存泄漏。

3. **系统崩溃**：在内存不足时，cow_handler 函数调用 panic 导致整个系统崩溃，而不是只杀死当前进程。

4. **代码冗余**：实现中存在大量重复代码，降低了可读性和维护性。

## 2. 内存分配器优化的实现

### 2.1 多核内存分配器优化

我们实现了每个 CPU 维护自己的空闲列表，并在需要时从其他 CPU 窃取内存的机制：

```c
// 尝试从其他CPU窃取内存
for(int i = 0; i < NCPU && new_pa == 0; i++) {
  acquire(&kmem[i].lock);
  if(kmem[i].freelist) {
    struct run *r = kmem[i].freelist;
    kmem[i].freelist = r->next;
    release(&kmem[i].lock);
    new_pa = (uint64)r;
    // 初始化新页面的引用计数为1
    acquire(&refcnt.lock);
    refcnt.ref_count[((uint64)r - KERNBASE) / PGSIZE] = 1;
    release(&refcnt.lock);
  } else {
    release(&kmem[i].lock);
  }
}
```

### 2.2 引用计数管理优化

我们优化了引用计数管理，确保在引用计数为 0 时正确释放页面：

```c
// 减少引用计数
void
dec_refcnt(void *pa)
{
  int idx = ((uint64)pa - KERNBASE) / PGSIZE;
  acquire(&refcnt.lock);
  refcnt.ref_count[idx]--;
  if(refcnt.ref_count[idx] == 0) {
    release(&refcnt.lock);
    // 引用计数为0，直接释放页面到空闲列表
    // 不调用kfree，避免递归
    struct run *r = (struct run*)pa;
    memset(pa, 1, PGSIZE); // Fill with junk to catch dangling refs.
    
    push_off();
    int cpu_id = cpuid();
    acquire(&kmem[cpu_id].lock);
    r->next = kmem[cpu_id].freelist;
    kmem[cpu_id].freelist = r;
    release(&kmem[cpu_id].lock);
    pop_off();
    return;
  }
  release(&refcnt.lock);
}
```

### 2.3 COW 缺页处理优化

我们优化了 COW 缺页处理，使其更加健壮：

```c
// 如果仍然无法分配内存，尝试等待一段时间
if(new_pa == 0) {
  for(int i = 0; i < 100 && new_pa == 0; i++) {
    yield();
    new_pa = (uint64)kalloc();
  }
}

// 如果仍然无法分配内存，杀死进程
if(new_pa == 0) {
  struct proc *p = myproc();
  if(p) {
    printf("cow_handler: out of memory, killing process %d", p->pid);
    setkilled(p);
  }
  return -1;
}
```

## 3. COW 与内存分配器的关系

COW (Copy-On-Write) 机制是一种内存优化技术，它允许多个进程共享相同的内存页面，直到其中一个进程尝试写入该页面时，才会创建该页面的副本。这种机制在 fork 系统调用中特别有用，因为它可以显著减少内存使用和提高 fork 的效率。

COW 与内存分配器密切相关，因为：

1. **页面共享**：COW 需要内存分配器支持页面共享，这通过引用计数来实现。

2. **页面复制**：当进程尝试写入 COW 页面时，需要分配新页面并复制内容，这依赖于高效的内存分配器。

3. **页面释放**：当页面不再被任何进程使用时，需要正确释放页面，这依赖于正确的引用计数管理。

## 4. 问题及 Bug 解决

### 4.1 内存泄漏问题

**问题**：在 dec_refcnt 函数中，只是简单地减少引用计数，但没有在引用计数为 0 时释放页面，导致内存泄漏。

**解决方案**：修改 dec_refcnt 函数，当引用计数为 0 时，直接将页面释放到空闲列表，避免递归调用 kfree。

### 4.2 系统崩溃问题

**问题**：在 cow_handler 函数中，当内存不足时调用 panic 导致整个系统崩溃，而不是只杀死当前进程。

**解决方案**：移除 panic 调用，改为打印错误信息并返回 -1，只杀死当前进程。

### 4.3 内存分配效率问题

**问题**：在内存严重不足时，系统无法有效地回收和重新分配内存。

**解决方案**：增加更健壮的内存分配策略，在从其他 CPU 窃取内存失败后，尝试等待一段时间并重新分配内存。

### 4.4 代码冗余问题

**问题**：实现中存在大量重复代码，降低了可读性和维护性。

**解决方案**：重构代码，减少重复，提高可读性。

## 5. 文档

### 5.1 内存分配器 API

- `kalloc()`：分配一个物理页面
- `kfree(void *pa)`：释放一个物理页面
- `get_refcnt(void *pa)`：获取页面的引用计数
- `inc_refcnt(void *pa)`：增加页面的引用计数
- `dec_refcnt(void *pa)`：减少页面的引用计数

### 5.2 COW 处理流程

1. 当进程尝试andler 处理缺页错误
3. 如果页面的写入一个 COW 页面时，触发缺页错误
2. 调用 cow_h引用计数为 1，直接将页面设置为可写
4. 否则，分配新页面，复制内容，更新页表项，并减少原页面的引用计数

### 5.3 优化策略

1. **多核内存分配**：每个 CPU 维护自己的空闲列表，在需要时从其他 CPU 窃取内存
2. **引用计数管理**：确保在引用计数为 0 时正确释放页面
3. **健壮的错误处理**：在内存不足时，尝试等待并重新分配，而不是立即崩溃
4. **代码简化**：减少重复代码，提高可读性和维护性

## 6. 结论

通过优化内存分配器和 COW 实现，我们解决了 kalloctest 测试中的问题，提高了系统的内存管理效率，特别是在处理大量 fork 操作和 COW 页面时。这些优化不仅解决了测试问题，还提高了整个系统的健壮性和性能。