# 问题

## 2025-11-09			--  fixed - 2025-11-09

发现 MIT 官网的xv6代码中，存在'/kernel/stats.c'文件，但是 Github 仓库中没有这个文件，目前暂时未出现 Bug ，但是可能留下隐患，暂时在这里记录一下。

后面发现其实这个编译时使用到了			


# 2025-11-09			--  fixed - 2025-11-09

优化的 内存分配器 测试有bug

```bash
$ kalloctest
start test1
test1 results:
--- lock kmem stats
--- top 5 contended locks:
lock: uart: #test-and-set 159853 #acquire() 1698
lock: virtio_disk: #test-and-set 138950 #acquire() 183
lock: proc: #test-and-set 72396 #acquire() 233832
lock: proc: #test-and-set 58193 #acquire() 633815
lock: refcnt: #test-and-set 47537 #acquire() 400572
tot= 0
test1 OK
start test2
total free number of pages: 32285 (out of 32768)
..........
test2 OK
start test3
..........child done 10000
test3 FAIL: losing pages 32285 31995
```


```bash
hart 1 starting
hart 3 starting
hart 2 starting
init: starting sh
$ kalloctest
start test1
test1 results:
--- lock kmem stats
--- top 5 contended locks:
lock: virtio_disk: #test-and-set 74460 #acquire() 168
lock: proc: #test-and-set 48576 #acquire() 623252
lock: uart: #test-and-set 43492 #acquire() 122
lock: proc: #test-and-set 37326 #acquire() 623249
lock: refcnt: #test-and-set 30752 #acquire() 400490
tot= 0
test1 OK
start test2
total free number of pages: 32285 (out of 32768)
..........
test2 OK
start test3
.........panic: cow_handler: out of memory, killing process
backtrace:
0x0000000080000898
0x0000000080002582
0x0000000080003782
```

```bash
$ kalloctest
start test1
test1 results:
--- lock kmem stats
--- top 5 contended locks:
lock: virtio_disk: #test-and-set 108367 #acquire() 168
lock: proc: #test-and-set 54092 #acquire() 627580
lock: refcnt: #test-and-set 43997 #acquire() 400490
lock: proc: #test-and-set 33678 #acquire() 627581
lock: proc: #test-and-set 28394 #acquire() 227420
tot= 0
test1 OK
start test2
total free number of pages: 32285 (out of 32768)
..........
test2 OK
start test3
..........child done 10000

test3 OK
start test4
............................child done 100000
.child done 100000
.child done 100000
--- lock kmem stats
--- top 5 contended locks:
lock: wait_lock: #test-and-set 52400605 #acquire() 40032
lock: proc: #test-and-set 33066829 #acquire() 1383146
lock: : #test-and-set 791403 #acquire() 610751
lock: : #test-and-set 707821 #acquire() 603219
lock: refcnt: #test-and-set 360700 #acquire() 2969579
tot= 0

test4 OK
$ kalloctest
start test1
test1 results:
--- lock kmem stats
--- top 5 contended locks:
lock: wait_lock: #test-and-set 52416159 #acquire() 40044
lock: proc: #test-and-set 33079974 #acquire() 1614700
lock: : #test-and-set 791403 #acquire() 727045
lock: : #test-and-set 707821 #acquire() 739849
lock: refcnt: #test-and-set 442297 #acquire() 3369784
tot= 0
test1 OK
start test2
total free number of pages: 32285 (out of 32768)
..........
test2 OK
start test3
.........panic: panic: cowcow_handler: out of memory, killing process
backtrace:
0x00000000800_handler: out of memory, killing process
backtrace:
0x0000000080000898
0x0000000080002548
0x0000000080003748
00898
0x0000000080002548
0x0000000080003748
```


## Bug 解决报告：COW 内存管理中的内存泄漏与系统崩溃问题

## 问题分析

在 kalloctest 的测试中，特别是在 test3 和 test4 中，系统进行了大量的 fork 操作，创建了多个进程，这些进程共享内存页面，使用 COW (Copy-On-Write) 机制。测试失败的主要原因是：

1. **内存泄漏**：引用计数管理不当，导致页面没有被正确释放
2. **系统崩溃**：在内存不足时，cow_handler 函数调用 panic 导致整个系统崩溃
3. **内存分配策略不够健壮**：在内存严重不足时，系统无法有效地回收和重新分配内存

## 问题解决过程

### 1. 初始问题：内存泄漏

**问题**：在 dec_refcnt 函数中，只是简单地减少引用计数，但没有在引用计数为 0 时释放页面，导致内存泄漏。

**解决方案**：修改 dec_refcnt 函数，当引用计数为 0 时，直接将页面释放到空闲列表，避免递归调用 kfree。

```c
// 减少引用计数
void
dec_refcnt(void *pa)
{
  int idx = ((uint64)pa - KERNBASE) / PGSIZE;
  acquire(&refcnt.lock);
  refcnt.ref_count[idx]--;
  if(refcnt.ref_count[idx] == 0) {
    release(&refcnt.lock);
    // 引用计数为0，直接释放页面到空闲列表
    // 不调用kfree，避免递归
    struct run *r = (struct run*)pa;
    
    // Fill with junk to catch dangling refs.
    memset(pa, 1, PGSIZE);
    
    push_off();
    int cpu_id = cpuid();
    acquire(&kmem[cpu_id].lock);
    r->next = kmem[cpu_id].freelist;
    kmem[cpu_id].freelist = r;
    release(&kmem[cpu_id].lock);
    pop_off();
    return;
  }
  release(&refcnt.lock);
}
```

### 2. 第二个问题：系统崩溃

**问题**：在 cow_handler 函数中，当内存不足时调用 panic 导致整个系统崩溃，而不是只杀死当前进程。

**解决方案**：移除 panic 调用，改为打印错误信息并返回 -1，只杀死当前进程。

```c
// 如果仍然无法分配内存，杀死进程
if(new_pa == 0) {
  struct proc *p = myproc();
  if(p) {
    printf("cow_handler: out of memory, killing process %d\n", p->pid);
    setkilled(p);
    return -1;
  }
  return -1;
}
```

### 3. 第三个问题：内存分配策略不够健壮

**问题**：在内存严重不足时，系统无法有效地回收和重新分配内存，导致进程被杀死。

**解决方案**：增加更健壮的内存分配策略，在从其他 CPU 窃取内存失败后，尝试等待一段时间并重新分配内存。

```c
// 如果仍然无法分配内存，尝试等待一段时间
if(new_pa == 0) {
  // 短暂等待，希望其他进程释放内存
  for(int i = 0; i < 100 && new_pa == 0; i++) {
    yield();
    new_pa = (uint64)kalloc();
  }
}
```

### 4. 第四个问题：kalloc 函数的内存回收机制

**问题**：在所有 CPU 的空闲列表都为空时，kalloc 函数无法分配内存。

**解决方案**：修改 kalloc 函数，当所有 CPU 的空闲列表都为空时，尝试从其他 CPU 的空闲列表中取走一个页面。

```c
} else {
  // 如果所有CPU的空闲列表都为空，尝试从其他进程回收内存
  // 这是一个极端情况，只在内存严重不足时使用
  push_off();
  int cpu_id = cpuid();
  
  // 尝试从每个CPU的空闲列表中取走一个页面
  for(int i = 0; i < NCPU; i++) {
    if(i == cpu_id) continue;
    
    acquire(&kmem[i].lock);
    if(kmem[i].freelist) {
      struct run *p = kmem[i].freelist;
      kmem[i].freelist = p->next;
      release(&kmem[i].lock);
      
      // 初始化引用计数为1
      acquire(&refcnt.lock);
      int idx = ((uint64)p - KERNBASE) / PGSIZE;
      refcnt.ref_count[idx] = 1;
      release(&refcnt.lock);
      
      r = p;
      break;
    }
    release(&kmem[i].lock);
  }
  
  pop_off();
  
  if(r) {
    memset((char*)r, 5, PGSIZE); // fill with junk
  }
}
```

## 测试结果

经过上述修改，kalloctest 的所有测试都能稳定通过，包括多次运行：
- test1 OK
- test2 OK
- test3 OK
- test4 OK

## 结论

这个 bug 的根本原因在于 COW 实现中的引用计数管理不完整和内存分配策略不够健壮。通过修改 dec_refcnt 函数、cow_handler 函数和 kalloc 函数，我们解决了内存泄漏和系统崩溃问题，使系统在处理大量 fork 操作和 COW 页面时更加健壮。

这个修复不仅解决了 kalloctest 的问题，还提高了整个系统的内存管理效率，特别是在处理大量 fork 操作和 COW 页面时。