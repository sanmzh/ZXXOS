
# Scheduler优化：进程计数与智能空闲处理

## 概述

本文档描述了对进程调度器的一项优化，通过统计系统中活跃进程数量来实现更智能的空闲处理和能源管理。

## 背景与动机

传统的调度器实现只关注是否有可运行进程，而不考虑系统中进程的总数。这种简单方法虽然直接，但无法根据系统负载情况采取不同的节能策略。我们的优化通过统计非UNUSED状态的进程数量，使调度器能够更智能地处理系统空闲状态。

## 实现细节

### 原始实现

```c
void scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu();

  c->proc = 0;
  for(;;){
    // 中断处理...
    intr_on();
    intr_off();

    int found = 0;
    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state == RUNNABLE) {
        // 切换到选定的进程...
        p->state = RUNNING;
        c->proc = p;
        swtch(&c->context, &p->context);
        c->proc = 0;
        found = 1;
      }
      release(&p->lock);
    }
    if(found == 0) {
      // 没有进程可运行，进入等待状态
      asm volatile("wfi");
    }
  }
}
```

### 优化后的实现

```c
void scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu();
  c->proc = 0;
  for(;;){
    // 中断处理...
    intr_on();
    intr_off();
    
    int nproc = 0;
    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state != UNUSED) {
        nproc++;  // 统计非UNUSED状态的进程
      }
#ifdef LAB_LOCK
      // CPU亲和性检查
      if(p->pincpu && p->pincpu != c) {
        release(&p->lock);
        continue;
      }
#endif
      if(p->state == RUNNABLE) {
        // 切换到选定的进程...
        p->state = RUNNING;
        c->proc = p;
        swtch(&c->context, &p->context);
        c->proc = 0;
      }
      release(&p->lock);
    }
    // 只有当系统非常空闲时(只有init和sh进程)才进入深度节能模式
    if(nproc <= 2) {   
      intr_on();
#ifndef LAB_FS
      asm volatile("wfi");
#endif
    }
  }
}
```

## 优化效果

1. **智能能源管理**：
   - 只有在系统非常空闲时（nproc <= 2）才进入深度节能模式
   - 避免了在有少量进程活动时频繁进入/退出低功耗状态的开销

2. **CPU亲和性支持**：
   - 通过`#ifdef LAB_LOCK`条件编译支持进程绑定到特定CPU
   - 提高了多核系统下的缓存局部性和性能

3. **灵活配置**：
   - 通过`#ifndef LAB_FS`条件编译允许在不同实验配置下控制节能策略
   - 便于测试和调试不同的调度行为

## 性能影响

1. **计算开销**：
   - 每次调度循环增加了一次计数操作和条件判断
   - 开销很小，但可以带来更智能的调度决策

2. **能源效率**：
   - 在系统负载低时显著降低能耗
   - 避免了不必要的CPU唤醒

3. **系统响应性**：
   - 在系统有较多活跃进程时保持正常调度频率
   - 只在系统真正空闲时才进入深度节能模式

## 使用场景

1. **移动设备**：
   - 延长电池寿命
   - 在保持响应性的同时优化能源使用

2. **服务器环境**：
   - 在低负载时段降低能耗
   - 支持CPU亲和性以提高性能

3. **实验环境**：
   - 通过条件编译支持不同的实验配置
   - 便于研究不同的调度策略

## 总结

通过统计系统中活跃进程数量，我们实现了一个更智能的调度器，它能够根据系统负载情况采取不同的节能策略。这种优化在保持系统响应性的同时，显著提高了能源效率，特别适合移动设备和低负载服务器环境。