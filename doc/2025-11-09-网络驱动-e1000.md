https://pdos.csail.mit.edu/6.828/2025/labs/net.html

您将使用一个名为 E1000 的网络设备来处理网络通信。对于 xv6（以及您编写的驱动程序）来说，E1000 看起来像一块真实的硬件，连接到真实的以太网局域网 (LAN)。事实上，您的驱动程序将要与之通信的 E1000 是由 qemu 提供的模拟，连接到一个同样由 qemu 模拟的局域网。在这个模拟的局域网中，xv6（“客户机”）有一个 IP 地址 10.0.2.15。Qemu 安排运行 qemu 的计算机（“主机”）出现在局域网中，IP 地址为 10.0.2.2。当 xv6 使用 E1000 向 10.0.2.2 发送数据包时，qemu 将数据包递送到主机上的相应应用程序。

您将使用 QEMU 的“用户模式网络栈”。QEMU 的文档中有更多关于用户模式栈的信息。我们已经更新了 Makefile 以启用 QEMU 的用户模式网络栈和 E1000 网络卡模拟。

Makefile 配置 QEMU 将所有传入和传出的数据包记录到您实验室目录中的文件 packets.pcap 中。查看这些记录可能有助于确认 xv6 是否正在发送和接收您期望的数据包。要显示记录的数据包：
```bash
tcpdump -XXnr packets.pcap
```

我们为本次实验向 xv6 存储库添加了一些文件。文件 kernel/e1000.c 包含 E1000 的初始化代码以及用于传输和接收数据包的空函数，您将填充这些函数。 kernel/e1000_dev.h 包含 E1000 定义的寄存器和标志位的定义，如 Intel E1000 软件开发者手册中所述。 kernel/net.c 和 kernel/net.h 包含一个简单的网络栈，实现了 IP、UDP 和 ARP 协议； net.c 包含用户进程发送 UDP 数据包的完整代码，但缺少大部分接收数据包并将其传递到用户空间的代码。最后， kernel/pci.c 包含在 xv6 启动时搜索 PCI 总线上的 E1000 卡的代码。

#  网络驱动实现详细文档

## 概述

本文档详细描述了为 ZXXOS（基于 MIT 6.S081 的 xv6 操作系统）添加的网络驱动实现。该实现包括 Intel E1000 网卡驱动、网络协议栈（以太网、IP、UDP）以及相关的系统调用接口，使操作系统能够通过网络发送和接收数据包。

## 文件结构

### 新增文件

1. **kernel/e1000.c** - Intel E1000 网卡驱动实现
2. **kernel/e1000_dev.h** - E1000 设备寄存器和数据结构定义
3. **kernel/net.c** - 网络协议栈实现
4. **kernel/net.h** - 网络相关数据结构和常量定义
5. **kernel/pci.c** - PCI 设备初始化代码
6. **user/nettest.c** - 网络功能测试程序
7. **nettest.py** - Python 测试脚本（在 QEMU 外运行）

### 修改的文件

1. **kernel/defs.h** - 添加了网络相关函数声明
2. **kernel/main.c** - 在初始化过程中添加了网络初始化
3. **kernel/memlayout.h** - 添加了 E1000_IRQ 定义
4. **kernel/plic.c** - 修改了中断处理逻辑
5. **kernel/spinlock.c** - 添加了原子操作函数
6. **kernel/syscall.c** - 添加了网络系统调用处理函数
7. **kernel/sysnum.h** - 定义了网络系统调用编号
8. **kernel/trap.c** - 添加了 E1000 中断处理
9. **kernel/vm.c** - 修改了内存管理
10. **user/user.h** - 添加了网络系统调用接口
11. **user/usys.pl** - 添加了网络系统调用入口点
12. **Makefile** - 添加了新文件的编译规则

## 网络驱动实现

### E1000 网卡驱动 (kernel/e1000.c)

E1000 驱动实现了以下功能：

1. **初始化**：
   - 复位网卡
   - 配置发送和接收描述符环
   - 设置 M送和接收功能
   - 配置中断

2. **发送功能** (`e1000_transmit`)：
   - 检查发送描述符是否可用
   - 设置描AC 地址过滤
   - 启用发述尾指针
   - 处理发送符字段（地址、长度、命令）
   - 更新发送完成后的资源释放

3. **接收功能** (`e1000_recv`)：
   - 检查接收描述符状态
   - 处理接收到的数据包
   - 分配新缓冲区替换已使用的缓冲区
   - 调用上层协议处理函数

4. **中断处理** (`e1000_intr`)：
   - 清除中断标志
   - 调用接收处理函数

### PCI 初始化 (kernel/pci.c)

PCI 初始化代码实现了以下功能：

1. 扫描 PCI 总线上的设备
2. 识别 E1000 网卡 (设备 ID 0x100e, 厂商 ID 0x8086)
3. 配置网卡 BAR (基地址寄存器)
4. 初始化 E1000 网卡

## 网络协议栈实现

### 网络协议栈 (kernel/net.c)

网络协议栈实现了以下功能：

1. **初始化** (`netinit`)：
   - 初始化网络锁
   - 设置本地 MAC 地址和 IP 地址

2. **系统调用实现**：
   - `sys_bind` - 绑定端口
   - `sys_unbind` - 解绑端口
   - `sys_send` - 发送 UDP 数据包
   - `sys_recv` - 接收 UDP 数据包

3. **数据包处理**：
   - `net_rx` - 网络数据包入口点，根据以太网类型分发处理
   - `ip_rx` - IP 数据包处理，验证并分发到上层协议
   - `arp_rx` - ARP 数据包处理，发送 ARP 回复

4. **数据包队列管理**：
   - 实现了基于链表的数据包队列
   - 支持入队、出队、判断空队列等操作
   - 限制队列长度防止资源耗尽

5. **数据包构造**：
   - `sys_send` 中构造完整的以太网/IP/UDP 数据包
   - 计算并设置校验和
   - 处理字节序转换

### 网络数据结构 (kernel/net.h)

网络数据结构定义包括：

1. **以太网帧结构** (`struct eth`)
2. **IP 数据包结构** (`struct ip`)
3. **UDP 数据包结构** (`struct udp`)
4. **ARP 数据包结构** (`struct arp`)
5. **DNS 数据包结构** (`struct dns`)

以及相关的常量定义和字节序转换函数。

## 系统调用接口

### 网络系统调用

实现了四个网络系统调用：

1. **bind(uint16 port)**
   - 绑定本地 UDP 端口
   - 返回 0 表示成功，-1 表示失败

2. **unbind(uint16 port)**
   - 解绑本地 UDP 端口
   - 返回 0 表示成功，-1 表示失败

3. **send(uint16 sport, uint32 dst, uint16 dport, char *buf, uint32 len)**
   - 发送 UDP 数据包
   - sport: 源端口
   - dst: 目标 IP 地址（网络字节序）
   - dport: 目标端口
   - buf: 数据缓冲区
   - len: 数据长度
   - 返回 0 表示成功，-1 表示失败

4. **recv(uint16 dport, uint32 *src, uint16 *sport, char *buf, uint32 maxlen)**
   - 接收 UDP 数据包
   - dport: 接收端口
   - src: 返回源 IP 地址
   - sport: 返回源端口
   - buf: 接收数据缓冲区
   - maxlen: 缓冲区最大长度
   - 返回接收到的数据长度，-1 表示失败

## 网络测试

### 测试程序 (user/nettest.c)

测试程序实现了多种测试场景：

1. **txone** - 发送单个数据包
2. **tx** - 发送多个数据包
3. **rx** - 接收数据包测试
4. **rx2** - 多端口接收测试
5. **ping0/ping1/ping2/ping3** - 不同场景的 ping 测试
6. **dns** - DNS 查询测试
7. **grade** - 综合测试

### 测试脚本 (nettest.py)

Python 测试脚本实现了测试服务器功能，用于配合内核测试程序进行网络功能验证。

## 系统集成

### 初始化流程

网络功能在系统启动时初始化：

1. 在 `main()` 函数中调用 `pci_init()` 初始化 PCI 设备
2. `pci_init()` 扫描并初始化 E1000 网卡
3. 调用 `netinit()` 初始化网络协议栈
4. 注册网络中断处理程序

### 中断处理

网络中断处理流程：

1. E1000 产生中断
2. PLIC (Platform-Level Interrupt Controller) 路由中断到 CPU
3. `trap.c` 中的 `devintr()` 函数处理中断
4. 调用 `e1000_intr()` 处理网卡中断
5. `e1000_intr()` 调用 `e1000_recv()` 接收数据包
6. `e1000_recv()` 调用 `net_rx()` 处理接收到的数据包

### 内存管理

网络功能使用 xv6 的内存管理系统：

1. 使用 `kalloc()`/`kfree()` 分配和释放网络缓冲区
2. 每个端口的数据包队列限制为 16 个数据包
3. 发送和接收描述符环使用静态分配的内存

## 使用示例

可参考 `user/nettest.c` 中的示例代码，了解如何使用网络系统调用发送和接收数据包。

以下是一个简单的网络使用示例：

```c
#include "kernel/net.h"
#include "user/user.h"

int main() {
  // 绑定本地端口 2000
  if(bind(2000) < 0) {
    printf("bind failed\n");
    exit(1);
  }
  
  // 发送数据包到 10.0.2.2:2001
  char msg[] = "Hello, world!";
  uint32 dst = MAKE_IP_ADDR(10, 0, 2, 2);
  if(send(2000, dst, 2001, msg, sizeof(msg)) < 0) {
    printf("send failed\n");
    exit(1);
  }
  
  // 接收数据包
  char buf[128];
  uint32 src;
  uint16 sport;
  int n = recv(2000, &src, &sport, buf, sizeof(buf)-1);
  if(n < 0) {
    printf("recv failed\n");
    exit(1);
  }
  
  buf[n] = '\0';
  printf("received from %d.%d.%d.%d:%d: %s\n", 
         (src>>24)&0xFF, (src>>16)&0xFF, (src>>8)&0xFF, src&0xFF,
         sport, buf);
  
  // 解绑端口
  unbind(2000);
  
  exit(0);
}
```

## 总结

ZXXOS 的网络驱动实现提供了一个基本的网络通信框架，支持通过 E1000 网卡发送和接收 UDP 数据包。该实现遵循了操作系统的分层设计原则，从硬件驱动到网络协议栈再到系统调用接口，每一层都有明确的职责和接口。

这个网络实现虽然功能相对简单，但足以支持基本的网络应用，并为更复杂的网络功能（如 TCP、套接字接口等）奠定了基础。通过测试程序的验证，证明了该网络实现的正确性和稳定性。