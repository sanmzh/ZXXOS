mmap 可以以多种方式调用，但此实验仅需要与其内存映射文件相关的功能子集。您可以假设 addr 始终为零，这意味着内核应决定映射文件的虚拟地址。 mmap 返回该地址，如果失败则返回 0xffffffffffffffff。 len 是要映射的字节数；它可能与文件长度不同。 prot 指示内存是否应映射为可读、可写和/或可执行；您可以假设 prot 是 PROT_READ 或 PROT_WRITE 或两者。 flags 要么是 MAP_SHARED ，表示对映射内存的修改应写回文件，要么是 MAP_PRIVATE ，表示不应写回。您不必在 flags 中实现任何其他位。 fd 是要映射文件的打开文件描述符。您可以假设 offset 为零（它是映射的文件起始点）。


您的实现应该惰性填充页表，以响应页面错误。也就是说， mmap 本身不应分配物理内存或读取文件。相反，应该在 usertrap 中的（或被 usertrap 调用的）页面错误处理代码中完成这些操作，就像在写时复制实验中那样。惰性的原因是为了确保大文件的 mmap 操作快速，并且可能对大于物理内存的文件进行 mmap 操作。


如果映射相同 MAP_SHARED 文件的不同进程不共享物理页面，这是可以接受的。

munmap 应该移除指定地址范围内的 mmap 映射（如果存在）。如果进程已修改内存并且将其映射为 MAP_SHARED ，则应首先将修改写入文件。一次 munmap 调用可能只覆盖 mmap 区域的一部分，但您可以假设它将在开始时取消映射，或在结束时取消映射，或整个区域（但不会在区域中间打孔）。当进程退出时，它对 MAP_SHARED 区域所做的任何修改都应写入相关文件，就好像该进程调用了 munmap 一样。


# mmap 实现思路与细节

## 1. 整体思路

mmap 系统调用允许将文件或其他对象映射到进程的地址空间，实现文件内容与内存之间的直接映射。在 xv6 中实现 mmap 需要考虑以下几个关键点：

1. **延迟分配（Lazy Allocation）**：mmap 调用本身不立即分配物理内存，而是记录映射信息，在实际访问时才分配物理内存并从文件读取内容。

2. **虚拟内存区域（VMA）管理**：在进程结构中维护 VMA 数组，记录每个映射区域的属性（地址、长度、权限、标志等）。

3. **页面错误处理**：当进程访问未分配的 mmap 区域时，触发页面错误，此时需要分配物理内存并从文件中读取数据。

4. **写时复制（Copy-on-Write）**：对于 MAP_PRIVATE 映射，当进程尝试写入时需要创建私有副本。

5. **munmap 处理**：取消映射时需要处理页面写回（MAP_SHARED）和资源释放。

## 2. 数据结构

在 `proc.h` 中定义虚拟内存区域结构：

```c
#define NVMA 16
// 虚拟内存区域结构体
struct vm_area
{
  int used;           // 是否已被使用
  uint64 addr;        // 起始地址
  int len;            // 长度
  int prot;           // 权限
  int flags;          // 标志位
  int vfd;            // 对应的文件描述符
  struct file *vfile; // 对应文件
  int offset;         // 文件偏移，本实验中一直为0
};
```

在进程结构中添加 VMA 数组：

```c
struct proc {
  // ... 其他字段 ...
  struct vm_area vma[NVMA]; // 虚拟内存区域
  // ... 其他字段 ...
};
```

## 3. mmap 系统调用实现

在 `sysfile.c` 中实现 `sys_mmap` 函数：

```c
uint64
sys_mmap(void)
{
  uint64 addr;
  int length;
  int prot;
  int flags;
  int vfd;
  struct file *vfile;
  int offset;
  uint64 err = 0xffffffffffffffff;

  // 获取系统调用参数
  argaddr(0, &addr);
  argint(1, &length);
  argint(2, &prot);
  argint(3, &flags);
  argfd(4, &vfd, &vfile);
  argint(5, &offset);

  // 实验提示中假定addr和offset为0，简化程序可能发生的情况
  if (addr != 0 || offset != 0 || length < 0)
    return err;

  // 文件不可写则不允许拥有PROT_WRITE权限时映射为MAP_SHARED
  if (vfile->writable == 0 && (prot & PROT_WRITE) != 0 && flags == MAP_SHARED)
    return err;

  struct proc *p = myproc();
  // 没有足够的虚拟地址空间
  if (p->sz + length > MAXVA)
    return err;

  // 遍历查找未使用的VMA结构体
  for (int i = 0; i < NVMA; ++i)
  {
    if (p->vma[i].used == 0)
    {
      p->vma[i].used = 1;
      p->vma[i].addr = p->sz;
      p->vma[i].len = length;
      p->vma[i].flags = flags;
      p->vma[i].prot = prot;
      p->vma[i].vfile = vfile;
      p->vma[i].vfd = vfd;
      p->vma[i].offset = offset;

      // 增加文件的引用计数
      filedup(vfile);

      p->sz += length;
      return p->vma[i].addr;
    }
  }

  return err;
}
```

## 4. 页面错误处理

在 `trap.c` 中实现 `mmap_handler` 函数处理 mmap 区域的页面错误：

```c
/**
 * @brief mmap_handler 处理mmap惰性分配导致的页面错误
 * @param va 页面故障虚拟地址
 * @param cause 页面故障原因
 * @return 0成功，-1失败
 */
int mmap_handler(int va, int cause)
{
  int i;
  struct proc *p = myproc();
  // 根据地址查找属于哪一个VMA
  for (i = 0; i < NVMA; ++i)
  {
    if (p->vma[i].used && p->vma[i].addr <= va && va <= p->vma[i].addr + p->vma[i].len - 1)
    {
      break;
    }
  }
  if (i == NVMA)
    return -1;

  int pte_flags = PTE_U;
  if (p->vma[i].prot & PROT_READ)
    pte_flags |= PTE_R;
  if (p->vma[i].prot & PROT_WRITE)
    pte_flags |= PTE_W;
  if (p->vma[i].prot & PROT_EXEC)
    pte_flags |= PTE_X;

  struct file *vf = p->vma[i].vfile;
  // 读导致的页面错误
  if (cause == 13 && vf->readable == 0)
    return -1;
  // 写导致的页面错误
  if (cause == 15 && vf->writable == 0)
    return -1;

  void *pa = kalloc();
  if (pa == 0)
    return -1;
  memset(pa, 0, PGSIZE);

  // 读取文件内容
  ilock(vf->ip);
  // 计算当前页面读取文件的偏移量，实验中p->vma[i].offset总是0
  // 要按顺序读读取，例如内存页面A,B和文件块a,b
  // 则A读取a，B读取b，而不能A读取b，B读取a
  int offset = p->vma[i].offset + PGROUNDDOWN(va - p->vma[i].addr);
  int readbytes = readi(vf->ip, 0, (uint64)pa, offset, PGSIZE);
  // 如果读到0字节，可能是文件末尾，这是正常情况
  // 不应该返回错误，而是继续使用已分配的页面（已清零）
  if (readbytes == 0)
  {
    iunlock(vf->ip);
    // 继续使用已分配的页面（已清零）
  }
  else
  {
    iunlock(vf->ip);
  }

  // 添加页面映射
  if (mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)pa, pte_flags) != 0)
  {
    kfree(pa);
    return -1;
  }

  return 0;
}
```

在 `trap.c` 的页面错误处理中添加对 mmap 的支持：

```c
// 在usertrap函数中添加以下代码
else if(r_scause() == 15 || r_scause() == 13) {
    // 处理写错误（可能是COW页面）或读错误（懒分配页面）
    uint64 va = r_stval();
    uint64 cause = r_scause();

    // 如果是写错误，尝试处理COW页面
    if(cause == 15) {
      pte_t *pte = walk(p->pagetable, va, 0);
      if(pte && (*pte & PTE_V) && (*pte & PTE_COW)) {
        if(cow_handler(p->pagetable, va) == 0) {
          // COW处理成功
          goto done;
        } else {
          // COW处理失败，可能是内存不足，杀死进程
          setkilled(p);
          goto done;
        }
      }
    }

    // 如果不是COW页面或者COW处理失败，检查是否是mmap区域
    int mmap_result = mmap_handler(va, cause);
    if(mmap_result == 0) {
      // mmap处理成功
      goto done;
    }

    // 如果不是mmap区域或者mmap处理失败，尝试懒分配
    uint64 vmfault_result = vmfault(p->pagetable, va, (cause == 13)? 1 : 0);

    if(vmfault_result != 0) {
      // vmfault成功，页面已分配
      goto done;
    } else {
      // vmfault返回0，需要区分不同情况
      if(va >= MAXVA || va >= KERNBASE) {
        // 访问内核地址空间或超过MAXVA的地址，杀死进程
        printf("usertrap(): invalid address va=%p, pid=%d\n", (void*)va, p->pid);
        setkilled(p);
      } else if(va >= p->sz) {
        // 超出进程大小限制，杀死进程
        printf("usertrap(): address beyond process size va=%p, pid=%d\n", (void*)va, p->pid);
        setkilled(p);
      } else {
        // 其他情况，可能是内存不足或其他错误，杀死进程
        printf("usertrap(): page fault at va=%p, pid=%d\n", (void*)va, p->pid);
        printf("            sepc=0x%lx scause=0x%lx\n", r_sepc(), cause);
        setkilled(p);
      }
    }
}
```

## 5. munmap 系统调用实现

在 `sysfile.c` 中实现 `sys_munmap` 函数：

```c
uint64
sys_munmap(void)
{
  uint64 addr;
  int length;
  argaddr(0, &addr);
  argint(1, &length);

  int i;
  struct proc *p = myproc();
  for (i = 0; i < NVMA; ++i)
  {
    if (p->vma[i].used && p->vma[i].len >= length)
    {
      // 根据提示，munmap的地址范围只能是
      // 1. 起始位置
      if (p->vma[i].addr == addr)
      {
        p->vma[i].addr += length;
        p->vma[i].len -= length;
        break;
      }
      // 2. 结束位置
      if (addr + length == p->vma[i].addr + p->vma[i].len)
      {
        p->vma[i].len -= length;
        break;
      }
    }
  }
  if (i == NVMA)
    return -1;

  // 将MAP_SHARED页面写回文件系统
  if (p->vma[i].flags == MAP_SHARED && (p->vma[i].prot & PROT_WRITE) != 0)
  {
    filewrite(p->vma[i].vfile, addr, length);
  }

  // 判断此页面是否存在映射
  uvmunmap(p->pagetable, addr, length / PGSIZE, 1);

  // 当前VMA中全部映射都被取消
  if (p->vma[i].len == 0)
  {
    fileclose(p->vma[i].vfile);
    p->vma[i].used = 0;
  }

  return 0;
}
```

## 6. fork 时的处理

在 `uvmcopy` 函数中添加对 VMA 的复制：

```c
// 在fork时复制VMA信息
for(i = 0; i < NVMA; i++) {
  if(p->vma[i].used) {
    np->vma[i] = p->vma[i];
    if(np->vma[i].vfile)
      filedup(np->vma[i].vfile);
  }
}
```

## 7. exec 时的处理

在 `exec` 函数中清除 VMA：

```c
// 清除所有VMA
for(i = 0; i < NVMA; i++) {
  if(p->vma[i].used) {
    if(p->vma[i].vfile)
      fileclose(p->vma[i].vfile);
    p->vma[i].used = 0;
  }
}
```

## 8. exit 时的处理

在 `exit` 函数中释放 VMA 资源：

```c
// 释放所有VMA资源
for(i = 0; i < NVMA; i++) {
  if(p->vma[i].used) {
    if(p->vma[i].vfile)
      fileclose(p->vma[i].vfile);
    p->vma[i].used = 0;
  }
}
```

## 9. 关键点总结

1. **延迟分配**：mmap 调用时不分配物理内存，只记录 VMA 信息。

2. **页面错误处理**：访问 mmap 区域时触发页面错误，此时分配物理内存并从文件读取数据。

3. **文件读取**：根据虚拟地址计算文件偏移，读取对应内容到物理内存。

4. **权限检查**：根据 mmap 时的权限设置页面权限，并在访问时检查。

5. **MAP_PRIVATE 处理**：对于 MAP_PRIVATE 映射，写入时需要创建私有副本（可以使用 COW 机制）。

6. **MAP_SHARED 处理**：对于 MAP_SHARED 映射，取消映射或进程退出时需要将修改写回文件。

7. **资源管理**：正确处理文件引用计数，避免资源泄漏。

这个实现方案解决了 mmaptest 失败的问题，特别是在页面错误处理时正确地从文件中读取数据到内存中。


---


# mmaptest 测试程序详解与 mmap 使用方法

## 1. mmaptest 测试程序详解

mmaptest 是一个用于测试 mmap 系统调用实现的测试程序，它验证了 mmap 功能的各种情况，包括：

### 1.1 测试内容

1. **基本 mmap 测试**：将文件映射到内存，验证映射内容与文件内容一致
2. **私有映射测试**：测试 MAP_PRIVATE 标志，确保修改不会影响原文件
3. **只读文件测试**：验证对只读文件不能进行 MAP_SHARED 可写映射
4. **读写文件测试**：验证对可读写文件可以进行 MAP_SHARED 可写映射
5. **脏页写回测试**：验证 MAP_SHARED 映射的修改能正确写回文件
6. **多文件映射测试**：同时映射多个文件，验证互不干扰
7. **fork 测试**：验证 fork 后子进程可以正确访问父进程映射的文件

### 1.2 测试流程

```c
// 1. 创建一个包含1.5页'A'和0.5页零的文件
void makefile(const char *f) {
  // ... 创建文件并写入内容
}

// 2. 检查映射内容的函数
void _v1(char *p) {
  // 验证前1.5页是'A'，后0.5页是0
}

// 3. 基本测试
void mmap_test(void) {
  // 创建文件
  makefile(f);
  fd = open(f, O_RDONLY);
  
  // 测试1: 只读映射
  p = mmap(0, PGSIZE * 2, PROT_READ, MAP_PRIVATE, fd, 0);
  _v1(p);  // 验证内容
  munmap(p, PGSIZE * 2);
  
  // 测试2: 私有可写映射
  p = mmap(0, PGSIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
  _v1(p);  // 验证内容
  for (i = 0; i < PGSIZE * 2; i++)
    p[i] = 'Z';  // 修改内容
  munmap(p, PGSIZE * 2);
  
  // 测试3: 只读文件的共享可写映射(应该失败)
  p = mmap(0, PGSIZE * 3, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  if (p != MAP_FAILED)
    err("mmap call should have failed");
  
  // 测试4: 读写文件的共享可写映射
  fd = open(f, O_RDWR);
  p = mmap(0, PGSIZE * 3, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  _v1(p);  // 验证内容
  for (i = 0; i < PGSIZE * 2; i++)
    p[i] = 'Z';  // 修改内容
  munmap(p, PGSIZE * 2);  // 只取消前2页
  
  // 验证修改已写回文件
  // ...
  
  // 测试5: 同时映射两个文件
  // ...
}

// 4. fork测试
void fork_test(void) {
  // 映射文件两次
  p1 = mmap(0, PGSIZE * 2, PROT_READ, MAP_SHARED, fd, 0);
  p2 = mmap(0, PGSIZE * 2, PROT_READ, MAP_SHARED, fd, 0);
  
  // fork子进程
  if (fork() == 0) {
    _v1(p1);  // 子进程验证内容
    munmap(p1, PGSIZE);  // 子进程取消部分映射
    exit(0);
  }
  
  wait(&status);  // 等待子进程
  
  // 验证父进程映射仍然有效
  _v1(p1);
  _v1(p2);
}
```

### 1.3 测试失败的原因

mmaptest 失败的主要原因是 mmap 的实现不完整，特别是：

1. **页面错误处理不正确**：当程序访问 mmap 映射的区域时，没有正确地从文件中读取数据到内存，导致读取到的是零页而不是文件内容。

2. **mmap_handler 未实现或实现有误**：在页面错误处理中没有调用 mmap_handler，或者 mmap_handler 实现有问题。

3. **文件读取逻辑错误**：在 mmap_handler 中，计算文件偏移量或读取文件内容的逻辑有误。

## 2. mmap 使用方法

### 2.1 函数原型

```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

### 2.2 参数说明

1. **addr**：指定映射的起始地址。通常设为 NULL，让内核自动选择合适的地址。
2. **length**：映射区域的长度（字节数）。
3. **prot**：映射区域的保护权限，可以是以下值的组合：
   - `PROT_READ`：可读
   - `PROT_WRITE`：可写
   - `PROT_EXEC`：可执行
   - `PROT_NONE`：不可访问
4. **flags**：映射类型和特性，可以是以下值的组合：
   - `MAP_SHARED`：共享映射，对映射区域的修改会写回文件，其他映射同一文件的进程可见
   - `MAP_PRIVATE`：私有映射，对映射区域的修改不会写回文件，其他进程不可见
   - `MAP_FIXED`：强制使用指定的 addr，如果该区域不可用则失败
   - `MAP_ANONYMOUS`：匿名映射，不与文件关联（fd 参数被忽略）
5. **fd**：要映射的文件描述符。对于匿名映射，设为 -1。
6. **offset**：文件中的偏移量（从哪里开始映射），必须是页面大小的整数倍。

### 2.3 返回值

- 成功：返回映射区域的起始地址
- 失败：返回 MAP_FAILED（通常是 (void *)-1），并设置 errno

### 2.4 使用示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
  int fd;
  char *map;
  
  // 打开文件
  fd = open("test.txt", O_RDWR);
  if (fd == -1) {
    perror("open");
    exit(1);
  }
  
  // 获取文件大小
  off_t size = lseek(fd, 0, SEEK_END);
  
  // 映射文件到内存
  map = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  if (map == MAP_FAILED) {
    perror("mmap");
    close(fd);
    exit(1);
  }
  
  // 现在可以像访问普通内存一样访问文件内容
  printf("文件内容: %s\n", map);
  
  // 修改内容
  map[0] = 'H';
  map[1] = 'e';
  map[2] = 'l';
  map[3] = 'l';
  map[4] = 'o';
  
  // 取消映射
  if (munmap(map, size) == -1) {
    perror("munmap");
  }
  
  // 关闭文件
  close(fd);
  
  return 0;
}
```

### 2.5 常见用法场景

1. **文件 I/O 优化**：对于大文件的随机访问，使用 mmap 可能比传统的 read/write 更高效。

2. **进程间通信**：通过 MAP_SHARED 映射同一文件实现进程间共享内存。

3. **零拷贝操作**：避免数据在内核空间和用户空间之间的复制。

4. **动态加载**：用于动态链接器加载共享库。

5. **内存分配**：通过 MAP_ANONYMOUS 实现内存分配。

### 2.6 注意事项

1. **内存对齐**：offset 和返回的地址通常是页面大小的整数倍。

2. **文件大小**：映射区域不能超过文件大小（除非使用 MAP_ANONYMOUS）。

3. **访问权限**：访问权限必须与文件打开模式兼容（例如，不能对只读打开的文件进行 MAP_SHARED 可写映射）。

4. **信号处理**：访问映射区域可能触发 SIGSEGV 或 SIGBUS 信号。

5. **资源释放**：使用 munmap 释放映射区域，避免内存泄漏。

6. **同步**：对于 MAP_SHARED 映射，修改不会立即写回磁盘，可以使用 msync 强制同步。

通过正确理解和使用 mmap，可以实现高效的文件操作和进程间通信。mmaptest 的失败提醒我们，在实现 mmap 时需要特别注意页面错误处理和文件内容加载的正确性。