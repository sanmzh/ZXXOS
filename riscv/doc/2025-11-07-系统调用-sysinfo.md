添加一个系统调用sysinfo，它收集有关正在运行的系统的信息。系统调用采用一个参数：一个指向struct sysinfo的指针（参见kernel/sysinfo.h*）。内核应该填写这个结构的字段：freemem字段应该设置为空闲内存的字节数，nproc字段应该设置为state字段不为UNUSED的进程数。我们提供了一个测试程序sysinfotest；如果输出“sysinfotest: OK*”则通过。

添加一个新的系统调用，获取 **空闲内存量** 和 **已经创建的进程数量** 并返回。


xv6 中，空闲内存页的记录方式是，将空虚内存页**本身直接用作链表节点**，形成一个空闲页链表，每次需要分配，就把链表根部对应的页分配出去。每次需要回收，就把这个页作为新的根节点，把原来的 freelist 链表接到后面。[细节详见 xv6-riscv-book ]


# 实现解释

sysinfo系统调用的实现在'/ZXXOS/kernel/sysproc.c'文件中，具体代码如下：

```c
// 获取系统信息
uint64
sys_sysinfo(void)
{
  struct sysinfo info;  // 创建一个sysinfo结构体变量，用于存储系统信息
  freebytes(&info.freemem);  // 调用freebytes函数获取空闲内存大小，并存入info.freemem
  proccount(&info.nproc);    // 调用proccount函数获取进程数量，并存入info.nproc

  // 获取用户传递的虚拟地址
  uint64 dstva;
  argaddr(0, &dstva);  // 从系统调用参数中获取第一个参数，即用户空间中sysinfo结构体的地址

  // 将 info 结构体从内核空间复制到用户空间
  if(copyout(myproc()->pagetable, dstva, (char *)&info, sizeof(info)) < 0)
    return -1;  // 如果复制失败，返回-1表示错误

  return 0;  // 成功返回0
}
```
这段代码的工作流程如下：
1. 定义一个sysinfo结构体变量info，用于存储系统信息。
2. 调用freebytes函数获取系统空闲内存大小：

```c
void freebytes(uint64* dst) {
  *dst = 0;
  struct run *r = kmem.freelist;
  
  acquire(&kmem.lock);      // 获取锁，防止其他线程修改
  while(r) {
    *dst += PGSIZE;         // 累加空闲内存大小
    r = r->next;
  }
  release(&kmem.lock);      // 释放锁
}
```
这个函数遍历内核的空闲内存链表，计算总的空闲内存字节数。

3. 调用proccount函数获取系统当前进程数量：

```c
void proccount(uint64* count) {
  *count = 0;
  struct proc* p;
  for(p = proc; p < &proc[NPROC]; ++p){
    if(p->state != UNUSED){
      (*count)++;
    }
  }
}
```
这个函数遍历进程表，统计所有状态不为UNUSED的进程数量。

4. 使用'argaddr'函数获取用户传递的参数，即用户空间中'sysinfo'结构体的地址。
5. 使用'copyout'函数将内核空间的'info'结构体复制到用户空间提供的地址中。
6. 如果复制成功，返回0；否则返回-1。

## sysinfo用户态使用方法
在用户态，使用sysinfo系统调用的步骤如下：
1. 包含必要的头文件：
```c
#include "kernel/types.h"
#include "kernel/sysinfo.h"
#include "user/user.h"
```

2. 声明一个sysinfo结构体变量：
```c
struct sysinfo info;
```

3. 调用sysinfo系统调用：
```c
if (sysinfo(&info) < 0) {
  printf("FAIL: sysinfo failed");
  exit(1);
}
```

4. 使用获取到的信息：
```c
printf("freemem: %ld bytes\n", info.freemem);
printf("nproc: %ld\n", info.nproc);
```

用户态的sysinfo函数是通过usys.pl脚本生成的汇编包装来调用内核的系统调用。该脚本为每个系统调用生成一个小的汇编函数，将系统调用号放入a7寄存器，然后执行ecall指令触发系统调用。

sysinfo系统调用在用户态和内核态之间的交互流程如下：

1. 用户程序调用sysinfo函数，传入sysinfo结构体指针
2. 汇编包装将系统调用号(SYS_sysinfo，值为23)放入a7寄存器
3. 执行ecall指令，触发陷阱，进入内核态
4. 内核根据系统调用号调用sys_sysinfo函数
5. sys_sysinfo函数收集系统信息，并通过copyout将结果复制回用户空间
6. 返回用户态，用户程序可以访问填充后的sysinfo结构体
这种设计允许用户程序安全地获取内核维护的系统信息，而无需直接访问内核数据结构。