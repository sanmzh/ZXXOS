# 打印页表

帮助你可视化 RISC-V 页表，也许有助于未来的调试

```bash
page table 0x0000000087f22000
 ..0x0000000000000000: pte 0x0000000021fc7801 pa 0x0000000087f1e000
 .. ..0x0000000000000000: pte 0x0000000021fc7401 pa 0x0000000087f1d000
 .. .. ..0x0000000000000000: pte 0x0000000021fc7c5b pa 0x0000000087f1f000
 .. .. ..0x0000000000001000: pte 0x0000000021fc705b pa 0x0000000087f1c000
 .. .. ..0x0000000000002000: pte 0x0000000021fc6cd7 pa 0x0000000087f1b000
 .. .. ..0x0000000000003000: pte 0x0000000021fc6807 pa 0x0000000087f1a000
 .. .. ..0x0000000000004000: pte 0x0000000021fc64d7 pa 0x0000000087f19000
 ..0x0000003fc0000000: pte 0x0000000021fc8401 pa 0x0000000087f21000
 .. ..0x0000003fffe00000: pte 0x0000000021fc8001 pa 0x0000000087f20000
 .. .. ..0x0000003fffffd000: pte 0x0000000021fd4813 pa 0x0000000087f52000
 .. .. ..0x0000003fffffe000: pte 0x0000000021fd00c7 pa 0x0000000087f40000
 .. .. ..0x0000003ffffff000: pte 0x0000000020001c4b pa 0x0000000080007000
 ```

第一行显示 vmprint 的参数。之后，每行显示一个 PTE，包括指向树中更深层的页表页面的 PTE。每个 PTE 行通过若干个 " .." 进行缩进，表示其在树中的深度。每个 PTE 行显示其虚拟地址、pte 位以及从 PTE 中提取的物理地址。不要打印无效的 PTE。在上述示例中，最顶层的页表页为条目 0 和 255 提供映射。条目 0 的下一级只有索引 0 被映射，而该索引 0 的底层有几个条目被映射。




# kpgtbl 页表打印系统调用文档

## 概述

kpgtbl 是一个系统调用，用于打印当前进程的页表内容，帮助开发者可视化 RISC-V 页表结构，对于调试和理解虚拟内存管理非常有用。

## 内核态实现

### 1. 系统调用号定义

在 `kernel/sysnum.h` 文件中定义了 kpgtbl 的系统调用号：

```c
#define SYS_kpgtbl     534    // 500 + 34 // 获取页表 // LAB_PGTBL
```

### 2. 系统调用处理函数

在 `kernel/sysproc.c` 文件中实现了系统调用处理函数：

```c
int
sys_kpgtbl(void)          // LAB_PGTBL
{
  struct proc *p;

  p = myproc();
  vmprint(p->pagetable);
  return 0;
}
```

该函数获取当前进程的进程结构体，然后调用 `vmprint` 函数打印当前进程的页表。

### 3. 页表打印函数

在 `kernel/vm.c` 文件中实现了页表打印的核心功能：

```c
void
vmprint(pagetable_t pagetable)      //  LAB_PGTBL
{
  printf("page table %p\n", pagetable);
  _vmprint(pagetable, 2, 0);
}

void
_vmprint(pagetable_t pagetable, int level, uint64 va)      //  LAB_PGTBL
{
  // 根据不同的层级计算每个页表项管理的地址空间大小
  uint64 sz;
  if(level == 2){
    sz = 512 * 512 * PGSIZE;  // level 2: 512个页目录项，每个页目录项管理512个页表项，每个页表项管理1个页
  } else if(level == 1){
    sz = 512 * PGSIZE;  // level 1: 512个页表项，每个页表项管理1个页
  } else {
    sz = PGSIZE;    // level 0: 1个页表项，管理1个页
  }

  for (int i = 0; i < 512; ++i, va += sz) { // 遍历当前页表中的所有512个页表项
    pte_t pte = pagetable[i];
    if ((pte & PTE_V) == 0)   // 检查每个页表项是否有效
      continue;
    for (int j = level; j < 3; ++j) {
      printf(" ..");
    }
    // 打印页表项的虚拟地址、PTE值和物理地址
    printf("%p: pte %p pa %p\n", (pagetable_t)va, (pagetable_t)pte, (pagetable_t)PTE2PA(pte));

    // 递归遍历
    if ((pte & (PTE_R | PTE_W | PTE_X)) == 0) { // 如果页表项不包含任何权限（R/W/X），说明这是一个指向下一级页表的指针
      _vmprint((pagetable_t)PTE2PA(pte), level - 1, va);
    }
  }
}
```

`vmprint` 函数是入口点，打印页表的基地址，然后调用 `_vmprint` 递归打印整个页表结构。`_vmprint` 函数根据层级计算每个页表项管理的地址空间大小，然后遍历当前页表的所有页表项，对于有效的页表项，打印其虚拟地址、PTE值和物理地址。如果页表项指向下一级页表，则递归调用 `_vmprint` 继续打印。

## 用户态使用方法

### 1. 系统调用声明

在 `user/user.h` 文件中声明了用户态接口：

```c
void kpgtbl(void);  	// LAB_PGTBL 打印页表
```

### 2. 系统调用生成

在 `user/usys.pl` 文件中添加了 kpgtbl 的系统调用生成代码：

```perl
entry("kpgtbl");
```

这会生成用户态调用内核的系统调用接口。

### 3. 使用示例

用户程序可以通过简单地调用 `kpgtbl()` 函数来打印当前进程的页表：

```c
#include "user.h"

int main() {
  printf("调用 kpgtbl 打印页表:\n");
  kpgtbl();
  exit(0);
}
```

### 4. 输出格式

kpgtbl 的输出格式如下：

```bash
page table 0x0000000087f22000
 ..0x0000000000000000: pte 0x0000000021fc7801 pa 0x0000000087f1e000
  .. ..0x0000000000000000: pte 0x0000000021fc7401 pa 0x0000000087f1d000
  .. .. ..0x0000000000000000: pte 0x0000000021fc7c5b pa 0x0000000087f1f000
  .. .. ..0x0000000000001000: pte 0x0000000021fc705b pa 0x0000000087f1c000
  .. .. ..0x0000000000002000: pte 0x0000000021fc6cd7 pa 0x0000000087f1b000
  .. .. ..0x0000000000003000: pte 0x0000000021fc6807 pa 0x0000000087f1a000
  .. .. ..0x0000000000004000: pte 0x0000000021fc64d7 pa 0x0000000087f19000
 ..0x0000003fc0000000: pte 0x0000000021fc8401 pa 0x0000000087f21000
  .. ..0x0000003fffe00000: pte 0x0000000021fc8001 pa 0x0000000087f20000
  .. .. ..0x0000003fffffd000: pte 0x0000000021fd4813 pa 0x0000000087f52000
  .. .. ..0x0000003fffffe000: pte 0x0000000021fd00c7 pa 0x0000000087f40000
  .. .. ..0x0000003ffffff000: pte 0x0000000020001c4b pa 0x0000000080007000
```

第一行显示页表的基地址。之后，每行显示一个页表项(PTE)，包括：
- 虚拟地址
- PTE值
- 从PTE中提取的物理地址

每个PTE行通过若干个" .."进行缩进，表示其在页表树中的深度。只有有效的PTE会被打印出来。

## 总结

kpgtbl 系统调用提供了一个简单而强大的工具，用于可视化RISC-V页表结构。它通过递归遍历页表树，打印出每个有效页表项的详细信息，包括虚拟地址、PTE值和物理地址，并以缩进格式展示页表层级关系。这对于理解虚拟内存管理和调试内存相关问题非常有帮助。


# 为什么说这个只会打印当前进程使用的页表


## 为什么 kpgtbl 只打印当前进程的页表

### 1. 系统调用的执行上下文

在操作系统中，系统调用是在特定进程的上下文中执行的。当用户程序调用 kpgtbl() 时，会发生以下过程：

1. 用户程序通过 `ecall` 指令触发系统调用
2. CPU 切换到内核模式，但仍然保持当前进程的上下文
3. 内核执行系统调用处理函数

### 2. sys_kpgtbl 函数的实现

让我们再看一下 sys_kpgtbl 函数的实现：

```c
int
sys_kpgtbl(void)          // LAB_PGTBL
{
  struct proc *p;

  p = myproc();  // 获取当前进程
  vmprint(p->pagetable);  // 打印当前进程的页表
  return 0;
}
```

关键在于 `myproc()` 函数，它返回的是**当前正在执行系统调用的进程**，而不是系统中所有的进程。

### 3. 进程与页表的关系

在 xv6 这类操作系统中：

1. 每个进程都有自己独立的页表
2. 进程结构体 (`struct proc`) 中包含一个指向其页表的指针 `pagetable`
3. 当进程切换时，CPU 的页表基址寄存器 (`satp`) 会被更新为当前进程的页表地址
4. 系统调用是在当前进程的上下文中执行的，因此 `myproc()` 返回的是当前进程

### 4. 内存隔离

现代操作系统的一个重要特性是进程间的内存隔离：

1. 每个进程只能访问自己虚拟地址空间映射的物理内存
2. 进程无法直接访问其他进程的内存
3. 系统调用虽然运行在内核模式，但仍然属于当前进程的上下文

### 5. 如果要打印所有进程的页表

如果要打印系统中所有进程的页表，需要遍历进程表，例如：

```c
void print_all_pagetables(void) {
  struct proc *p;
  
  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state != UNUSED) {
      printf("Process %d's page table:\n", p->pid);
      vmprint(p->pagetable);
    }
    release(&p->lock);
  }
}
```

但 kpgtbl 的设计目的是查看当前进程的页表，而不是所有进程的。

## 总结

kpgtbl 只打印当前进程的页表，是因为：

1. 系统调用是在特定进程的上下文中执行的
2. `myproc()` 函数返回的是当前正在执行系统调用的进程
3. 每个进程都有自己独立的页表，存储在进程结构体中
4. 操作系统的设计保证了进程间的内存隔离

这种设计是有意义的，因为在大多数情况下，开发者关心的是当前进程的内存布局，而不是整个系统中所有进程的内存布局。如果需要查看其他进程的页表，通常需要通过其他机制（如调试器）来实现。