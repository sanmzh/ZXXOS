# backtrace

为了调试，通常很有用有一个回溯：在错误发生点的栈上函数调用列表。为了帮助回溯，编译器生成机器代码，在栈上为当前调用链中的每个函数维护一个栈帧。每个栈帧包括返回地址和一个指向调用者栈帧的“帧指针”。寄存器 s0 包含一个指向当前栈帧的指针（它实际上指向栈上保存的返回地址的地址加 8）。你的 backtrace 应该使用帧指针遍历栈并打印每个栈帧中保存的返回地址。

一旦您的回溯功能开始工作，从 panic 在 kernel/printf.c 中调用它，以便在内核恐慌时看到内核的回溯。

# 实现

```C
// 打印调用栈轨迹
void
backtrace(void)
{
  uint64 fp = r_fp();  // 获取当前帧指针
  uint64 top = PGROUNDDOWN(fp);  // 当前栈页的起始地址
  
  printf("backtrace:\n");
  
  // 遍历栈帧链表
  while(fp != 0 && PGROUNDDOWN(fp) == top) {
    // 获取返回地址 (位于 fp-8 处)
    uint64 ret = *(uint64*)(fp - 8);
    printf("%p\n", ret);
    
    // 获取上一级帧指针 (位于 fp-16 处)
    fp = *(uint64*)(fp - 16);
  }
}
```

# 测试

在 sys_pause 中插入对该函数的调用
```C
// 打印调用栈轨迹
void
backtrace(void)
{
  uint64 fp = r_fp();  // 获取当前帧指针
  uint64 top = PGROUNDDOWN(fp);  // 当前栈页的起始地址
  
  printf("backtrace:\n");
  
  // 遍历栈帧链表
  while(fp != 0 && PGROUNDDOWN(fp) == top) {
    // 获取返回地址 (位于 fp-8 处)
    uint64 ret = *(uint64*)(fp - 8);
    printf("%p\n", (void*)ret);
    
    // 获取上一级帧指针 (位于 fp-16 处)
    fp = *(uint64*)(fp - 16);
  }
}
```

```bash
ZXXOS kernel is booting

hart 1 starting
hart 2 starting
init: starting sh
$ bttest
backtrace:
0x0000000080002c24
0x0000000080002ad0
0x0000000080002850
$ QEMU: Terminated
(base) sanm@LAPTOP-HF5A3H6A:~/OS/ZXXOS$ addr2line -e kernel/kernel
0x0000000080002c24
/home/sanm/OS/ZXXOS/kernel/sysproc.c:78
0x0000000080002ad0
/home/sanm/OS/ZXXOS/kernel/syscall.c:181 (discriminator 1)
0x0000000080002850
/home/sanm/OS/ZXXOS/kernel/trap.c:80
```
1. 最底层（trap.c:80）
    - 位置：/home/sanm/OS/ZXXOS/kernel/trap.c:80
    - 这是最开始的调用点，很可能是处理系统调用中断的入口点
2. 中间层（syscall.c:181）
    - 位置：/home/sanm/OS/ZXXOS/kernel/syscall.c:181
    - 这是系统调用分发函数，根据系统调用号调用相应的系统调用处理函数
3. 最顶层（sysproc.c:78）
    - 位置：/home/sanm/OS/ZXXOS/kernel/sysproc.c:78
    - 这是 sys_pause 函数中的位置，正好是我们添加 backtrace() 调用的地方



# 参考

在 **x86-64 体系结构** 下，一个典型的**栈帧** 的内存布局。它基于两个关键约定：

1.  **栈从高地址向低地址增长**。
2.  **帧指针** 指向当前栈帧的一个固定位置。

---

### 核心概念解释

*   **栈帧**：当一个函数被调用时，操作系统会在调用栈上为其分配一块内存区域，用于存储该函数的局部变量、参数、返回地址等信息。这块内存区域就是一个栈帧。
*   **帧指针**：通常是一个寄存器（在 x86-64 中是 `RBP` 寄存器），它的值被固定为指向**当前函数栈帧的起始位置**。通过帧指针，函数可以稳定地访问自己的局部变量和调用上下文，即使栈指针（`RSP`）在函数执行期间发生变化也没关系。
*   **返回地址**：这是函数执行完毕后，应该跳转回去继续执行的下一条指令的地址。是由 `CALL` 指令自动压入栈的。
*   **上一级帧指针**：为了在函数返回时能恢复调用者（上一级函数）的栈帧，当前函数需要将调用者的帧指针值保存起来。这个保存操作（`push rbp`）是函数开头（序言）的标准步骤。

---

### 内存布局分析

假设我们有一个调用链：`main` -> `foo`。

当 `foo` 函数正在执行时，它的栈帧布局如下图所示（注意：地址是向下增长的）：

```
高地址
+-------------------+
| ...               | <--- main 函数的栈帧
+-------------------+
| main 的局部变量    |
| ...               |
+-------------------+
| 返回地址 (到 main) | <--- RBP - 8   [1]
+-------------------+
| 保存的 RBP (main) | <--- RBP - 16  [2]
+-------------------+
| foo 的局部变量     |
| ...               | <--- RSP (当前栈顶)
+-------------------+
低地址
```

**详细分解：**

1.  **进入 `foo` 函数时**：
    *   `CALL foo` 指令首先将**返回地址**（即 `main` 函数中 `CALL` 指令之后的下一条指令的地址）压入栈顶。
    *   然后，跳转到 `foo` 函数执行。

2.  **`foo` 函数的序言**：
    ```asm
    push   rbp        ; 将 main 函数的帧指针值保存到栈上。此时 RSP 自动减少8。
    mov    rbp, rsp   ; 将 RBP 设置为新的栈顶，现在 RBP 指向当前栈帧的开始。
    sub    rsp, 32    ; 为 foo 的局部变量在栈上分配空间（例如 32 字节）。RSP 下移。
    ```

3.  **布局形成**：
    在执行完上面的序言代码后，栈的状态就固定了：
    *   **`RBP` 寄存器** 指向一个特定的位置，我们称之为 "帧指针"。
    *   **`[RBP]`**（即 `RBP` 指向的内存）存储着**上一级帧指针**（也就是 `main` 函数的 `RBP` 值）。
    *   **`[RBP - 8]`** 这个内存位置存储着**返回地址**。
    *   **`[RBP - 16]`** 以及更低的地址，可以用来存储 `foo` 函数的局部变量等。

---

### 回到你的那句话

> “返回地址位于帧指针 -8 的位置，而上一级帧指针位于帧指针 -16 的位置”

*   **`帧指针 - 8`**： 在 64 位系统中，每个地址是 8 字节。`-8` 意味着从 `RBP` 指向的位置向上移动一个 8 字节的“格子”，这里存放的就是**返回地址**。
*   **`帧指针 - 16`**： 从 `RBP` 指向的位置向上移动两个 8 字节的“格子”，这里存放的就是**上一级帧指针**（保存的旧 `RBP` 值）。

**为什么是这个顺序？**
因为 `CALL` 指令压入返回地址发生在函数序言之前，而 `push rbp` 是函数序言的第一步。所以返回地址在栈上的位置比保存的 `RBP` 更高（在内存地址更大的地方）。

---

### 总结与类比

你可以把栈帧想象成一摞文件（栈帧），每个文件都有一个标签（帧指针 `RBP`）。

*   标签（`RBP`）本身指着文件中的某一页。
*   在这一页上，写着上一个文件的标签在哪里（`[RBP]` = 上一级帧指针）。
*   翻到这一页的**前面一页**（`RBP - 8`），你找到了“看完这个文件后该回到哪个文件”的指示（返回地址）。
*   再往前翻（`RBP - 16` 及以后），就是这个文件自己的具体内容（局部变量）。

这种 `RBP` 相对寻址的方式，为函数提供了一个稳定、可预测的访问其栈帧内容的途径，是理解函数调用、调试器和栈回溯机制的基础。